[toc]
# 基础篇

## 1. 基础架构：SQL查询语句如何执行

![mysql逻辑架构图](D:\Desktop\markdown\MySQL实战45讲\mysql逻辑架构图.png)

	大体上分为Server层和存储引擎层两部分
	
	指定引擎：`create table`的时候通过`engine=memory`来指定使用某个内存引擎创建

注：memory是个引擎

### 1. 连接器（TCP）

1. 连接命令：

```sql
mysql -h$ip -P$port -u$user -p
```

可以在-p后面直接指定密码，但是这样或暴漏密码，不建议

2. **权限**：认证通过后，连接器会到限表里面查出你拥有的权限，之后此连接的权限都依赖于此时读到的权限；即便建立连接后，管理员对此用户权限修改，也要在新连接建立时才会使用新的权限

3. **空闲状态**：连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，通过`show processlist`可以查看；Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接

   客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。

![show_processlist](D:\Desktop\markdown\MySQL实战45讲\show_processlist.png)

4. **长连接和短链接**：数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

   因为建立连接比较复杂，建议使用长连接

5. **长连接OOM问题**：MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

   解决方案：

   - 定期断开长连接：一段时间，或占用内存大的操作后断开重连
   - MySQL5.7及以上版本，可以执行`mysql_reset_connection`初始化连接资源，此过程不需要重连和重新权限验证，但会将连接恢复到刚刚创建完时的状态

### 2. 查询缓存（8.0版本已删除）

建立连接后，执行select，逻辑来到查询缓存

1. **原理**：MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 **key-value** 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。

   如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。

2. **不建议使用**：查询缓存的**失效非常频繁**，只要有对一个表的**更新**，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。

   - 将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存

   - 确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定

   ```sql
   mysql> select SQL_CACHE * from T where ID=10；
   ```

   **注意：MySQL 8.0 版本直接将查询缓存的整块功能删掉了**

### 3. 分析器

解析SQL语句

1. 词法分析：识别语句的字符串分别是什么，代表什么

2. 语法分析：根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

   语法错误一般会提示第一个出现错误的位置

### 4. 优化器

分析器后，mysql知道了我们要做什么，但执行前要先优化

1. 优化内容：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序

![优化举例](D:\Desktop\markdown\MySQL实战45讲\优化举例.png)

### 5. 执行器

执行前要查看对此表是否有查询的权限，有的话才打开表

打开表后，根据表的引擎定义，使用引擎的接口

**举例：**

```sql
mysql> select * from T where ID=10;
```

这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的:

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

有索引的表逻辑也差不多



**查询日志：**`rows_examined`字段表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。

## 2. 日志系统：更新语句如何执行



### 1. 日志模块：redo log

![老板记账](D:\Desktop\markdown\MySQL实战45讲\老板记账.png)

	MySQL 里也有这个问题，如果每一次的**更新操作都需要写进磁盘**，然后**磁盘也要找到对应的那条记录**，然后再更新，整个过程 **IO 成本、查找成本**都很高

 2. **WAL技术（Write-Ahead Logging）**，借用上面粉板的思路提升效率

    它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。

    具体步骤：当有一条记录需要更新的时候，InnoDB 引擎就会

       	1. 先把记录写到 redo log（粉板）里面；
                	2. 并更新内存，这个时候更新就算完成了；
             	3. 在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事
                    	4. 如果日志满了，就放下手中的活，先把日志一部分记录更新到磁盘，然后删掉日志这部分记录，为新日志让空间

 3. **WAL具体流程**和**crash-safe**：

    InnoDB的redo log大小固定，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。**从头开始写，写到末尾回到开头循环**

![WAL具体](D:\Desktop\markdown\MySQL实战45讲\WAL具体.png)

- **write pos** 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。**checkpoint** 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
- write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 **crash-safe**。

### 2. 日志模块：binlog

MySQL主要为server层，主要负责功能侧面，还有一块为引擎层，负责存储相关

redo log是InnoDB引擎特有的

binlog（归档日志）属于server层

1. 两种日志的原因：

   最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。

### 3. 两种日志的区别（第二点没懂？）

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。

2. redo log 是**物理日志**，记录的是“在某个数据页上做了什么修改”；binlog 是**逻辑日志**，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。

3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

### 4. update内部流程

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
4. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

![update流程](D:\Desktop\markdown\MySQL实战45讲\update流程.png)

你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交

### 5. 两阶段提交

两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案

原因：让两份日志之间的逻辑一致

文章开头问题：**怎样让数据库恢复到半个月内任意一秒的状态？**

1. 数据恢复过程：

   - binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。（有点像redis的AOF和RDB）
   - 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做（AOF）：
     - 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
     - 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。

   这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。

2. 需要两阶段提交的反证：

   仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？

   - **先写 redo log 后写 binlog**。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。
   - **先写 binlog 后写 redo log**。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

   如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

   

   不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。

简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

3. 两个开启参数
   - innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。
   - sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

### 6. 后记

redo log不是记录更新之后的状态，而是记录这个页**做了什么改动**，例如某一行的某个字段加了1

Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。



## 3. 事物隔离：主讲隔离性

MySQL中，事物是在引擎层实现的；MySQL原生的MyISAM不支持事务，这是它被InnoDB取代的重要原因之一。

### 0. 并发带来的问题：脏，不可重复，幻

- **脏读**：两个事务T1,T2，T1读取了T2更新但<font color=red>还没有提交</font>的字段，此时若T2回滚，T1读取的内容就是临时且无效的
- **不可重复读**：两个事务T1,T2，T1读取了一个字段，然后T2<font color=red>更新</font>了该字段后，T1再次读取同一个字段，值就不同了
- **幻读**：两个事务T1,T2，T1从一个表中读取一个字段，然后T2在此表中<font color=red>插入</font>了一些新的行，之后，T1再次读取同一个表，就会多出几行

### 1. 隔离性和隔离级别

1. 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
2. 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
3. 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
4. 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

举例：

```sql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```



![隔离级别举例.png](D:\Desktop\markdown\MySQL实战45讲\隔离级别举例.png)

1. 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
2. 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
3. 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
4. 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。



### 2. 隔离级别的实现——概述

#### 1. 隐藏列（调研补充）

innodb中，每个表会有两个**隐藏列**（准确是三个，还有一个是隐藏ID，当建表时没指定主键，就会生成隐藏ID作为主键）。

- 版本号trx_id：创建该行数据的事务id
- 回滚指针roll_pointer

#### 2. undo log——回滚日志（调研补充）

事务对数据行进行一次更新操作时，会把旧数据行记录在一个叫做undo log的记录中，

数据行中除了数据，还会记录创建当前行数据的事务id和回滚指针，**原来数据行中的回滚指针指向undo log记录的这行数据**；然后在原来数据表更新，如果更新回滚，就根据回滚指针还原；这个操作会形参一条链表——版本链，链表头是最新数据，

对于上面加黑的解释：因为是把旧数据存在undo log中了，因此才说的是原来数据行指向undo log中的这行数据，此时的**原来数据行是更新过的新数据**

![版本链.png](D:\Desktop\markdown\MySQL实战45讲\版本链.png)

数据本来是刘备，然后事务id为100的事务先修改成了关羽，再修改成了张飞，后面事务id为200的事务先修改成了赵云，再修改成了诸葛亮

事务的可见性都是基于undo log实现的

#### 3. 视图的概念

查询时则依赖视图ReadView，实现不同隔离级别的关键

数据库里面会创建视图，视图是一个**事务快照**，准确来说是当前时间点系统内活跃的事务列表

#### 4. 大概实现

访问的时候以视图的逻辑结果为准

1. 可重复读：视图在事务启动时创建，整个事务存在期间都在用这个视图
2. 读提交：视图在每个SQL开始执行的时候创建
3. 读未提交：直接返回记录上最新值，没有视图概念
4. 串行化：直接加锁避免并行访问

#### 5. 具体实现（调研）

	查询一条数据时，事务会拿到这个ReadView，去到undo log中进行判断。若查询到某一条数据：

- **先去查看undo log中的最新数据行，如果数据行的版本号小于ReadView记录的事务id最小值，就说明这条数据对当前数据库是可见的，可以直接作为结果集返回**
- **若数据行版本号大于ReadView记录最大值，说明这条数据是由一个新的事务修改的，对当前事务不可见，那么就顺着版本链继续往下寻找第一条满足条件的**
- **若数据行版本号在ReadView最小值和最大值之间，那么就需要进行遍历了整个ReadView了，如果数据行版本号等于ReadView的某个值，说说明该行数据仍然处于活跃状态，那么对当前事务不可见**



注意：Oracle默认read committed，因此oracle迁移到mysql时，要把mysql设置为read committed。

- **可重复读的场景**：假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

- **配置的方式：**将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。你可以用 show variables 来查看当前的值。

### 3. 事务隔离实现——可重复读（调研的要比这一条讲得具体）

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。（隐藏列，事务id和回滚指针，结合undo log）

假设一个值从 1 被按顺序改成了 2、3、4，在**回滚日志**(undo log)里面就会有类似下面的记录。

![回滚日志.png](D:\Desktop\markdown\MySQL实战45讲\回滚日志.png)

当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。

#### 1. 何时删除回滚日志

在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。

什么时候才不需要了呢？就是当**系统里没有比这个回滚日志更早的 read-view** 的时候。

#### 2. 不使用长事务的原因

1. 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会**导致大量占用存储空间**。

在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。

2. 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。

### 4. 事务启动方式

#### 1. 两种启动方式

1. 显示启动
   - begin或start transaction
   - 提交commit
   - 回滚rollback
2. set autocommit = 0， 关掉当前线程的自动提交意味着执行一个select语句，事务就启动了，并且不会提交；直到主动执行commit或rollback，或断开连接

注意：有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，我会建议你总是使用 set autocommit=1, 通过显式语句的方式来启动事务。

#### 2. 多一次交互

第一种方式每次需要主动begin一次，多一次语句交互

那么建议使用**commit work and chain**

**在 autocommit 为 1 的情况下**，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是**提交事务并自动启动下一个事务**，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

#### 3. 查询长事务

可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

## 4. 深入浅出索引 上

### 1. 索引常见模型

1. 哈希表：**适用于只有等值查询的场景**，比如Memcached以及其他一些NoSQL引擎
2. 有序数组：只适用于**静态存储**引擎，比如2017年某个市全部人口信息，这种不会再修改的数据
3. 二叉搜索树：搜索效率高，但大多数数据库存储不适用二叉树，因为**索引不止存在内存中，还要写到磁盘上**。
   1. 因此多路搜索树更适合，也就是N叉树
   2. 以InnoDB的一个整数字段索引为例，N差不多为1200；树高为4，可以存1200的3次方个值，这已经是17亿了。考虑到**树根的数据块总是存在内存中**的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。
   3. 总结N叉树有点：
      1. 读写性能优秀
      2. 适配磁盘的访问模式
4. 还有跳表和LSM树等结构



### 2. InnoDB的索引模型

InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表**

每一个索引，在InnoDB中对应一颗B+树



假设一个表，主键为ID，表中字段K，K上有索引

建表语句：

```sql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树示意图如下：

![索引组织结构.png](D:\Desktop\markdown\MySQL实战45讲\索引组织结构.png)

从图中可以看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引

### 3. 主键索引和非主键索引，二者查询的区别

主键索引：叶子节点存整行数据，在innodb中也叫做聚簇索引

非主键索引：叶子节点内容是主键的值，也成为非聚簇索引，二级索引



**二者查询的区别：**

 - `select * from T where ID=500`，即主键查询，只需要搜索ID这颗B+树
 - `select * from T where k=5`，即普通索引，需要先搜索K索引树，得到ID值为500，再到ID所引述搜一次。这个过程称为**回表**。
 - 总结：非主键索引的查询，需要多扫描一颗索引树；因此应用中**尽量使用主键查询**

### 4. 索引维护

为了维护索引有序，因此插入新值的时候需要维护B+树

以上面的图为例，如果新插入的ID为700，只需要在R5后面插入新记录，如果为400，需要逻辑上挪动后面的数据，空出位置

**页分裂：**更糟糕的是，如果R5所在数据页满了，根据B+树的算法，需要申请新的数据页，挪动部分数据过去，这个过程称为**页分裂**。

**缺点：**除了**性能**以外，页分类还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，**整体空间利用率降低大约50%**。



**页合并：**相邻的两个页由于删除了数据，利用率很低，就会对数据页做合并。

### 5. 自增主键——案例分析

案例：你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。


​	

 - **自增主键作为主键**

	**自增主键**：指自增列上定义的主键，在建表语句中一般是这么定义的： 

`NOT NULL PRIMARY KEY AUTO_INCREMENT`。插入新记录的时候可以不指定ID的值，系统会获取当前ID的最大值，加1作为下一条记录的ID值。

	优点：	

1. 性能：自增主键的插入数据模式，符合递增插入的场景，每次插入，都是追加操作，不涉及挪动其他记录，就**不会出发叶子节点的分裂**。

2. 存储空间：**主键长度越小，普通索引的叶子节点越小，普通索引占用的空间也就也越小**，如果是业务字段，比如身份证号做主键，叶子节点大约20个字节，整型做主健，只要4个字节

   因此，从性能和存储空间方考量，自增主键往往是更合理的选择。



- **适合业务字段做主键的场景**

  1. 只有一个索引
  2. 该索引必须是唯一索引

  这就是典型的KV场景，没有其他索引，就不需要考虑其他索引叶子节点的大小问题。





问题：“N叉树”的N值在MySQL中是可以被人工调整的么？曾经面试被问到过这问题，当时就懵逼了...

作者回复:  面试中题面越简单的问题越暗藏凶险，可见一斑…

可以按照调整key的大小的思路来说；

如果你能指出来5.6以后可以通过page大小来间接控制应该能加分吧

面试回答不能太精减，计算方法、前缀索引什么的一起上😄

## 5. 深入浅出索引 下

### 1. 非聚簇索引回表分析

	初始化一张表

```sql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

	问题：执行`SELECT * from T where k between 3 and 5`，需要执行几次树的搜索操作，会扫描多少行？

![索引的结构1.png](D:\Desktop\markdown\MySQL实战45讲\索引的结构1.png)

	SQL的执行流程：

1. 在k索引树找到K=3，取得ID=300；
2. 再到ID树上找到ID=300对应的R3；
3. 在K树上取下一个值k=5，取得ID=500；
4. 再到ID树上找到ID=500对应的R4；
5. 在k树取下一个值K=6，不满足条件，循环结束。



这个过程中，**回到主键索引树搜索的过程，成为回表**。

这个查询过程，读了k树三条记录，回表两次。





### 2. 覆盖索引

上面select语句中的如果改成ID，这时只需要查ID的值，而ID的值已经在k索引树上，因此可以直接提供查询结果，不需要回表。也就是查询主键的话，索引K已经“覆盖”了我们的查询需求，这个就成为**覆盖索引**。

覆盖索引可以减少树的搜索次数，显著提升查询性能，因此是一个常用的性能优化手段



注意：引擎内部覆盖索引在索引k上其实读了3个记录，R3-R5（对应索引k上的记录项），但对于MySQL的Sercer层来说，他就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2.



基于覆盖索引，讨论问题：一个市民信息表，是否有必要讲身份证号和名字建立联合索引？市民表定义如下：

```sql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

因为身份证号是唯一标识，因此查询市民信息的话，只需要身份证号来查询就够了，在建立联合索引岂不是浪费空间？

如果有一个高频请求，要根据身份证号查询姓名，联合索引就有意义了。它可以在这个高频请求上，用到覆盖索引，不需要回表查整行记录，减少语句的执行时间。

当然，索引的维护是有代价的，简历冗余索引来支持覆盖索引，就需要权衡考虑

### 3. 最左前缀原则

不频繁的请求，不创建索引，要走全表扫描；单独创建索引，又有点浪费。

**B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录**

用（name，age）这个联合索引来分析

![（name，age）索引示意图.png](D:\Desktop\markdown\MySQL实战45讲\（name，age）索引示意图.png)

只要满足最左前缀，就可以利用索引加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。比如要查的是所有名字中第一个字是“张”的人，查询到的第一个符合条件的记录是ID3，然后向后遍历直到条件不满足。



问题：建立联合索引的时候，如何安排索引内的字段顺序。

第一原则：如果通过调整顺序，可以少维护一个索引，那么这个索引往往就是需要优先采用的。例如有了(a,b)，就不需要单独在a上建立索引了。

如果查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的。此时需要同时维护(a,b),(b)两个索引。此时要考虑的原则就是空间了，比如name比age字段大，那么就建议创建(name,age)的联合索引和(age)的单字段索引

### 4. 索引下推

满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。那些不符合最左前缀的部分，会怎么样呢

以市民表的联合索引(name,age)为例，现在一个需求是：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。SQL语句如下：

```sql
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

根据最左匹配原则，这个语句搜索索引树的时候，只能用“张”，找到第一个满足条件的记录ID3。

然后需要判断其他条件是否满足。

 - MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值
 - MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对**索引中包含的字段先做判断**，直接过滤掉不满足条件的记录，减少回表次数。

![无索引下推的执行流程.png](D:\Desktop\markdown\MySQL实战45讲\无索引下推的执行流程.png)

![有索引下推的执行流程.png](D:\Desktop\markdown\MySQL实战45讲\有索引下推的执行流程.png)

​	上图1中，又特意去掉了age的值。这个过程InnoDB不会去看age的值，只是按顺序把name第一个字是”张“的记录一条条取出来回表，需要四次回表

​	图2的区别是，Innodb在(name,age)索引内部就判断了age是否为10，不为10的记录直接判断并跳过，只需要回表两次

## 6. 全局锁和表级锁

​	MySQL锁大致分成全局、表、行三种。此处不涉及锁的实现细节，主要介绍碰到锁时的现象和其背后的原理。

### 1. 全局锁

​	需要让整个库处于可读状态时。后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

- **加锁：**`Flush tables with read lock (FTWRL)`

- **解锁：**`unlock tables`
- **典型使用场景：**全库逻辑备份，把整库每个表都select出来存成文本。



​	如果整个库只读，会产生两个问题：

1. 在主库备份，那么主库备份期间不能更新，业务要停

2. 从库备份，备份时不同执行主库的binlog，主从延迟

   

​    但如果不加锁就备份，恢复时会出错，如下，或者是扣钱了但没买课。也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。![image-20210121185243110](D:\Desktop\Markdown\MySQL实战45讲\备份.png)

​	

​	解决：在可重复读的隔离级别下开启一个事务。

​	官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。注：single-transaction 方法**只适用于所有的表使用事务引擎的库**。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。



​	也许会问，既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式，主要有两个原因：

- 一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式**影响面更大**。
- 二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会**自动释放**这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会**一直保持 readonly 状**态，这样会导致整个库长时间处于不可写状态，风险较高。



### 2. 表级锁

​	表级别的锁有两种：1. 表锁；2. 元数据锁（meta data lock，MDL)。

​	**表锁加锁：**`lock tables ... read/write`。与FTWRL类似，可以用`unlock tables`主动释放锁，也可以在客户端断开时自动释放。注意：lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

​	举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。

​	对于InnoDB这种支持行锁的引擎，一般不适用lock tables控制并发

​	**MDL元数据锁**：保证读写的正确性。元数据锁是server层的锁，表级锁，主要用于隔离DML（Data Manipulation Language，数据操纵语言，如select）和DDL（Data Definition Language，数据定义语言，如改表头新增一列）操作之间的干扰。每执行一条DML、DDL语句时都会申请MDL锁，DML操作需要MDL读锁，DDL操作需要MDL写锁（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥）

​	MySQL 5.5 版本中引入了 MDL，**当对一个表做增删改查操作的时候，加 MDL 读锁**；**当要对表做结构变更操作的时候，加 MDL 写锁。**



- MDL读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。此处的意思是对于表结构的增删改查。（元数据锁 **指的是DML 和 DDL 之间的锁** 不是DML 语言 update 和 select 语句之间的操作锁）
- MDL读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。





​	**虽然 MDL 锁是系统默认会加的，但却是你不能忽略的一个机制**。比如下面这个例子，我经常看到有人掉到这个坑里：**给一个小表加个字段，导致整个库挂了。**

​	给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据（索引要根据表中的每一行的记录值来创建，所以需要全表扫描；加字段或修改字段，也要修改每一行记录中的对应列的数据，所以也要全表扫描）。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表 t 是一个小表。

![image-20210121195208974](D:\Desktop\Markdown\MySQL实战45讲\MDL.png)



可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。之后 **session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞**。**原因**：**<u>申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁</u>**。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到MDL锁后，直到事务执行完才会将锁释放。（这里有种特殊情况如果事务中包含DDL操作，mysql会在DDL操作语句执行前，隐式提交commit，以保证该DDL语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放，例如id 44的语句改为<begin;alter table testok add z varchar(10) not Null;select * from testok;>，此时一旦alter语句执行完成会马上提交事务（autocommit=1），后面的select就在本次事务之外，其执行完成后不会持有读锁）。



​	如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。

​	前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。

​	你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

上面的例子，关于session d会插队c，关于online ddl：https://blog.csdn.net/q2878948/article/details/96430129

​	**问题：如何安全地给小表加字段？**

1. 首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。
2. 