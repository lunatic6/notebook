

# 1. Java基础知识

## 1. 基础部分

### 1. 面向对象

1. 面向对象编程：

   一种设计思想，把对象作为程序基本单元，对象包含了数据和操作数据的函数；把程序视为一组对象的集合，每个对象可以接受其他对象发的消息，并且处理，程序的执行就是一系列消息在对象间的传递

2. Java三大特性：

   - 封装：隐藏对象的属性和实现细节，仅对外公开访问方法，控制读写访问级别；封装的关键在于，绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。
   - 继承：在已有类的基础上，增加新的方法或重写已有方法，从而产生新类
   - 多态：相同的事务，调用相同的方法，参数也相同时，但表现不同
     - 继承是多态实现的基础

3. 实现多态的三个必要条件

   - 继承
   - 重写
   - 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。
   
   - String的本质是一个char数组value，并且用final修饰
   
     - 数组变量只是stack上的一个引用，数组的本地结构在heap堆中，final表示stack里面这个叫value的引用不能变，但是array里面的数据可以变
   
   - String的字符串常量池
   
     ```java
     String one = "someString";
     String two = "someString";
     ```
   
     one和two指向同一个地址

### 2. 接口和抽象类的区别

|     参数     |                 接口                 |            抽象类            |
| :----------: | :----------------------------------: | :--------------------------: |
|   默认方法   |        jdk1.8可以，之前不可以        |       可以实现默认方法       |
|    继承性    | 多实现，并且接口和接口之间可以多继承 |            单继承            |
| 可以有构造器 |         无构造器，不能实例化         |         可以有构造器         |
|    关键字    |        implements，interface         |      extends，abstract       |
|     main     |               没有main               |    有main方法，可以运行它    |
|     速度     |    稍慢，需要时间找类中实现的方法    |             更快             |
|   静态方法   |        jdk1.8可以，之前不可以        |                              |
|  访问修饰符  |              全为public              |       可以有protected        |
|   设计理念   |        like-a，是一种行为规范        | is-a，体现关系延续，模板设计 |

### 3. String为什么是final的

[具体看](https://www.zhihu.com/question/31345592)

保证String的“不可变性”，不可被继承



### 4. 类初始化过程

![类初始化过程](D:\Desktop\markdown\images\类初始化过程.png)

## 2. 集合

Java常用集合类

- Collection接口：
  - List接口
    - ArrayList
    - linkedlist
    - vector
  - Set接口
    - Hashset
    - treeset
- Map接口
  - hashMap
    - linkedHashMap
  - Treemap
  - hashtable
    - properties

### 1. HashMap

- 默认容量：16

- 最大容量：2^30

- 加载因子：0.75

- 扩容机制：

  - 是Node节点的数量大于**阈值**时才扩容，而不是数组中被占位置的数量
  - 添加后判断，而不是添加前

  

#### 1. 1.7和1.8的区别

1. 底层结构：
   - 1.7 数组+链表
   - 1.8 数组+链表+红黑树
     - 并不是链表长度大于8就转化为红黑树
     - 链表长度大于8，并且当前桶的长度不小于64的时候转化为红黑树
     - 如果链表长度大于8，但桶长度小于64，就扩容一次
2. 数组创建：
   - 1.7 new HashMap的时候创建数组
   - 1.8 第一次put方法的时候创建数组
3. 插入方式：
   - 1.7头插法，resize的时候会死循环
   - 1.8尾插法
4. resize时的方式
   - 1.7中resize的时候，所有Entry重新hash & length - 1
   - 1.8中resize，计算新参与进来的二进制高位是否为1
     - 如果为1，新位置=旧位置+原先的容量
     - 如果为0，新位置=旧位置
5. 1.7底层Entry数组，1.8Node数组

#### 2. 和hashtable的区别

 1. Hashtable不允许键或值为null，hashmap做了特殊处理

    ```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    ```

    原因：hashtable使用**安全失败机制（fail-safe）**，读到的数据未必是新数据，使用null值，就无法判断对应的key是不存在还是为空，因为无法再调用一次contain(key)，concurrenthashmap也是

    - 关于安全失败和快速失败
      - 快速失败：线程A正在便利集合，线程B对集合修改，或者线程A遍历的时候修改集合，A都会抛出 ConcurrentModificationException 异常。
        - 因为遍历过程会使用modCount变量，如果被遍历期间内容变化，就修改modCount的值，每次调用hashNext/next前，都会比较会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。
      - 安全失败：遍历时，是在集合的拷贝上进行遍历的

 2. 实现方式：hashtable继承Dictionary，hashmap继承abstractmap

 3. 初始化容量：hashmap16，table11，加载因子都是0.75

 4. 扩容机制：map翻倍，hashtable当前容量翻倍+1

 5. 迭代器：hashmap中iterator是fail-fast，table是fail-safe

 6. 定位桶：hashtable直接对桶长度取余，hashmap是 & length - 1

### 2. ConcurrentHashMap

结构也是数组+链表，由segment数组+hashentry组成

![CHM](D:\Desktop\markdown\images\CHM.jpg)

hashentry和hashmap差不多，不同的是使用volatile修饰了数据value和下一个节点next

分段锁：segment继承reentrantlock

get方法不加锁



1.8后：放弃了segment分段锁，采用cas+synchronized

数据结构也是数组+链表+红黑树



# 2. 多线程

## 1. 线程池

## 2. 公平锁与非公平锁优缺点

- 公平锁：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁
  - 优点：等待锁的线程不会饿死
  - 缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒线程的开销比非公平锁要大
- 非公平锁：多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待；但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请先获取锁的场景。
  - 优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程
  - 缺点：等待队列中的线程可能会饿死，或者等很久才会获得锁。

![webp](D:\Desktop\markdown\images\webp.jpeg)

![webp1](D:\Desktop\markdown\images\webp1.jpeg)



# 3. 设计模式

## 1. 单例模式

### 1. 双重校验锁

``` java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
```

- 第一次判断null：singleton对象已经创建，避免进入同步代码块，提升效率

- 第二次判断null：此时singletion为null，线程A经过第一次判断singleton为null，此时线程B获得时间片，也判断singleton为null，因此进入同步代码快实例化；如果没有第二次判断，线程A就会又new一个对象，不符合单例模式要求

- 为什么加volatile

  - 保证指令不会重排序

  - 可见性和有序性保证

    ```java
    singleton = new Singleton();  
    ```

    指令1：获取singleton对象的内存地址
    指令2：初始化singleton对象

    指令3：将这块内存地址，指向引用变量singleton。

   如果没有Volatile关键字，假设线程A正常创建一个实例，那么指定执行的顺序可能2-1-3，当执行到指令1的时候，线程B执行getInstance方法，获取到的，可能是对象的一部分，或者是不正确的对象，程序可能就会报异常信息。



---



# 4. JVM

## 1. 类加载过程

1. 加载：将class字节码文件加载到内存，把静态数据转换成方法区运行时数据结构，生成代表这个类的Class对象，作为方法区中类数据的访问入口

2. 链接

   - 验证：确保字节流包含信息符合当前虚拟机要求，保证类的正确性

     - 文件格式，元数据，字节码，符号引用

   - 准备：为类变量（不包括final，final在编译的时候就分配）分配内存并设置默认初始值，这些内存都在方法区中分配

   - 解析：常量池内的符号引用（常量名）替换为直接引用（地址）

3. 初始化：类构造器<clinit\>，收集类变量的赋值动作和静态代码块并执行

   

## 2. 运行时数据区

线程共享：

- 方法区：类信息，常量，静态变量等
- 堆：对象实例，数组

线程独立：

- 虚拟机栈：Java方法（局部变量表，操作数栈，动态链接，方法出口）
- 程序计数器
- 本地方法栈

## 3. 垃圾回收



# 5. MySQL

## 1. 事务

- 定义：**事务由单独单元的一个或多个SQL语句组成，这个单元中，每个MySQL语句相互依赖的。**整个单独单元是<u>不可分割的整体</u> ，如果单元中某条SQL执行失败或产生错误，整个单元会回滚。所有收到影响的数据返回到事务开始以前的状态；如果单元中所有SQL语句都执行成功，则事务顺利执行。

  

### 1. ACID四大属性

1. **原子性**：事务是一个不可分割的工作单位，事务中操作要么全部执行，要么全部不执行
2. **一致性**：事务执行使数据库从一个一致状态切换到另一个一致状态
3. **隔离性**：一个事务的执行不能被其他事物干扰；一个事务内部的操作和使用的数据对并发的其他事物是隔离的，并发执行的各个事务之前不能相互干扰
4. **持久性**：一个事务一旦提交，对数据库数据的改变是永久的，接下来其他操作和数据库故障对此改变无影响

### 2. 使用过程

```sql
set autocommit=0;

start transaction; // 可选
语句...

commit; 提交事务

rollback;回滚事务
```



### 3. 并发问题与隔离级别

#### 1. 并发问题

同时运行多个事务，访问**数据库中相同的数据**时，会导致各种并发问题

- **脏读**：两个事务T1,T2，T1读取了T2更新但<font color=red>还没有提交</font>的字段，此时若T2回滚，T1读取的内容就是临时且无效的
- **不可重复读**：两个事务T1,T2，T1读取了一个字段，然后T2<font color=red>更新</font>了该字段后，T1再次读取同一个字段，值就不同了
- **幻读**：两个事务T1,T2，T1从一个表中读取一个字段，然后T2在此表中<font color=red>插入</font>了一些新的行，之后，T1再次读取同一个表，就会多出几行



#### 2. 隔离级别

**数据库事务隔离性**：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免并发问题



数据库提供了4种**隔离级别**

- **READ UNCOMMITED(读取未提交数据)**：允许事务读取未被其他事务提交的变更；脏读，不可重复读，幻读都会出现
- **READ COMMITED(读已提交数据)**：只允许事务读取已经被其他事务提交的变更，可避免脏读，其他两种不能避免
- **REPEATABLE READ(可重复读)**：确保事务可以多次从一个字段读取相同的值；这个事务持续期间，禁止其他事务对这个字段更新；可以避免脏读和不可重复读
- **SERIALIZABLE(串行化)**：确保一个事务可以从一个表中读取相同的行；这个事务持续期间，禁止其他事务对该表插入，更新和删除；可避免所有并发问题，但性能十分辣鸡



> - Oracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE；默认为READ COMMITED
> - MySql支持4种：默认为REPEATABLE READ

![img](D:\Desktop\markdown\images\clipboard.png)

#### 3. 操作

每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation，表示当前事务隔离级别

- 查看当前隔离级别

  ```sql
  SELECT @@tx_isolation;
  ```

- 设置当前连接的隔离级别

  ```sql
  set transaction isolation level read committed；
  ```

- 设置数据库系统的全局隔离级别；

  ```sql
  set global transaction isolation level read committed；
  ```

----

## 2. 存储引擎

### 1. InnoDB和MyISAM

![引擎](D:\Desktop\markdown\images\引擎.jpeg)



# 6. Redis

## 1. 事务（没答上来）

### 1. 事务命令

1. DISCARD：取消事务，放弃事务块内所有命令
2. EXEC：执行所有事务块内命令
3. MULTI：标记事务块开始
4. UNWATCH：取消WATCH命令对所有key的监视
5. WATCH key[key..]：监视一个或多个key，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。

## 2. 五种基本数据类型及其操作

redis存储类型和底层数据结构

- list：双向链表
- set：value为null的hash表
- String：最基本数据类型
- hash：String类型的k-v映射表，类似hashmap
- zset：hash和跳跃列表

|                        List                         |                     Set                     |                  String                   |                 Hash                  |                 Zset                 |
| :-------------------------------------------------: | :-----------------------------------------: | :---------------------------------------: | :-----------------------------------: | :----------------------------------: |
|         **lpush/rpush** key value1 value2..         |        **sadd** key value1 value2..         |                **get** key                |         hset key filed value          | zadd key score1 value1 score2 value2 |
|                  **lpop/rpop** key                  |              **smembers** key               |             **set** key value             |            hget key field             |  zrange ket start stop [withscores]  |
|               **rpoplpush** key1 key2               |           **sismember** key value           |           **append** key value            | hmset key field1 value1 field2 value2 |  zrangebyscore key min max [with..]  |
|              **lrange** key start stop              |           **scard** key 元素个数            |              **strlen** key               |                hgetall                |     zrevrangebyscore key max min     |
|                **lindex** key index                 |         **srem** key value1 value2          |   **setnx** key value key不存在时设置值   |           hexists key field           |     zincrby key increment value      |
|                    **llen** key                     |     **spop** key 随机返回一个值;不删除      |             **incr/decr** key             |               hkeys key               |            zrem key value            |
|   **linset** key **before/after** value new value   | **srandmember** key n 随机返回n个值，不删除 |        **incrby/decrby** key 步长         |               hvals key               |          zcount key min max          |
| **lrem** key n value n为负，从右到左；为0，删除全部 |          **sinter** key1 key2 交集          |         **mset** key1 v1 key2 v2          |      hincrby key field increment      |   zrank key value 返回排名 从0开始   |
|                                                     |          **sunion** key1 key2 并集          |            **mget** key1 key2             |        hsetnx key field value         |                                      |
|                                                     |          **sdiff** key1 key2 差集           |      **msetnx** key1 val1 key2 val2       |                                       |                                      |
|                                                     |                                             |        **getrange** key start stop        |                                       |                                      |
|                                                     |                                             |       **setrange** key start value        |                                       |                                      |
|                                                     |                                             |       **setex** key 过期时间 value        |                                       |                                      |
|                                                     |                                             | **getset** key value 设置新值同时获得旧值 |                                       |                                      |

## 3. 基础

### 1. 分布式锁

​	用**setnx**争抢锁，抢到之后，用**expire**给锁加一个过期时间，防止忘记释放锁

### 2. setnx之后，expire之前，进程意外crash或者重启维护，怎么办

**	set**指令有参数，可以把**setnx**和**expire**合成一条指令来使用（事务？）

### 3. 一亿个key，其中10w个key是以某个已知的前缀开头，如何全部找出

​	使用**keys**可以扫出指定模式的key列表

### 4. redis正在给线上业务提供服务，keys指令有什么问题

​	Redis单线程，keys会导致线程阻塞一段时间，直到指令执行完毕；会导致服务停顿。可以用**scan**指令，无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，客户端再做一次去重即可。整体花费的时间会比keys更长

​	scan的缺点：scan属于增量式迭代命令，在对键迭代的过程中，键可能会被修改，因此增量式迭代命令只能对被返回的元素提供有限的保证。

### 4. redis做异步队列

#### 1. 如何使用

​	使用list作为队列，**rpush**生产消息，**lpop**消费消息，lpop没有消息的时候，要适当sleep一会，再重试。

#### 2. 可不可以不适用sleep

​	list还有一个指令叫**blpop**，没有消息的时候，会阻塞，直到消息到来

#### 3. 能不能生成一次，消费多次

​	使用pub/sub主题订阅者模式，可以实现1：N的消息队列

#### 4. pub/sub缺点

​	消费者下线，生产的消息会丢失，要使用专业的消息队列如RocketMQ

### 5. Redis实现延时队列（没太懂

​	使用sortedset，用时间戳作为score，消息内容作为key调用zadd圣翰消息，消费者用zrangebyscrore获取N秒之前的数据，进行轮训处理。

### 6. 持久化

RDB——镜像全量持久化，AOF增量持久化

RDB可以理解为一整个表全量的数据，AOF是每次操作的日志。

Redis本身的机制是：AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功；AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。

### 7. 突然断电

​	取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

### 8. RDB的原理

​	fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是**copy on write**，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

### 9. pipeline的好处（没懂

​	可以将多次IO往返的时间缩减为一次，前提是**pipeline**执行的指令之间没有因果相关性。使用**redis-benchmark**进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是**pipeline**批次指令的数目。

### 10. Redis同步机制

​	redis可以主从同步，从从同步。第一次同步时，主节点做一次**bgsave**，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

### 11. redis集群

## 4. 缓存雪崩，穿透，击穿

### 1. 雪崩

​	一般缓存都是定时刷新，或者查不到之后去更新。定时刷新的话就有雪崩的问题

​	**概念：**在高QPS访问时，缓存中大量的key同时失效，导致大量请求直接打到DBA，DBA直接挂掉，重启，又被新的流量打死。

​	**解决：**批量往Redis存数据时，每个key的失效时间都加一个随机值，保证数据不会在同一时间大面积失效。或者设置热点数据永不过期，或者有更新操作的话就更新缓存（比如首页商品更新，就刷新下缓存）。

### 2. 穿透

​	**概念：**指缓存和数据库中都没有的数据，而用户不断发起请求，就可能是攻击者，攻击导致数据库压力大，数据库挂掉。

​	例如不对参数校验，查询数据库id，id都是大于0，但一直用小于0的参数请求，每次都绕开Redis直接打到数据库，数据库也差不多，每次都这样，并发高一些就崩掉了。

​	**解决：**接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接return，比如ID<=0的拦截

​	还有一种高级用法**布隆过滤器**，原理是利用高效的数据结构和算法，快速判断这个key是否在数据库中存在，不存在直接return，存在就去差了DB刷新KV再return

### 3. 击穿

​	**概念**：类似于雪崩，但是雪崩是因为key大面积失效，击穿是一个key非常热点，大并发集中访问这一个点，这个key失效的瞬间，大并发就穿破缓存，直接请求数据库。

​	**解决：**热点数据永不过期，或者加上互斥锁

![缓存总结.png](D:\Desktop\markdown\images\缓存总结.png)

## 5. 哨兵，主从

​	Redis单线程，但是服务器多核的，因此我们可在单机开多个Redis实例（没懂）

​	**集群**：Redis cluster，主从同步读写分离，类似MySQL的主从同步，Redis cluster支撑N个Redis master node，每个master node可以挂在多个slave node。

​	**集群高可用的方式（除了持久化）**：

1. 



## 6. 持久化

1. RDB: 数据快照，周期性持久化

   - 优点：
     - 生成数据快照，每一份快照代表某一时刻Redis里面的数据
     - 对Redis性能影响小，因为同步数据的时候，fork一个子进程做持久化，数据恢复也比AOF快
   - 缺点：
     - 快照文件的生成有时间间隔，有可能会丢失掉某一间隔的数据；而AOF最多丢一秒的数据
     - 生成数据快照时，如果文件很大，客户端可能会暂停几毫秒甚至几秒，可能会造成问题

2. AOF：记录每一条写入命令，以 **append-only** 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的**binlog**。

   - 优点：
     - 一秒一次通过后台线程fsync操作记录日志，最多丢失一秒数据
     - 以append-only方式写，只是追加的方式写数据，没有磁盘寻址的开销，写入性能高，文件不易破损
     - **AOF**的日志是通过一个叫**非常可读**的方式记录的，这样的特性就适合做**灾难性数据误删除**的紧急恢复了，比如公司的实习生通过**flushall**清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份**AOF**日志文件，把最后一条**flushall**命令删了就完事了。
   - 缺点：
     - 相同的数据，AOF文件更大
     - **AOF**开启后，**Redis**支持写的**QPS**会比**RDB**支持写的要低，他不是每秒都要去异步刷新一次日志嘛**fsync**，当然即使这样性能还是很高

   注：AOF开启时，redis默认使用aof重新构建数据

## 7. Redis速度快的原因

1. 完全基于内存，绝大部分请求是存储的内存操作
2. 数据结构简单，对数据的操作也简单，其中的数据结构是专门设计的
3. 单线程，避免了不必要的上下文切换和竞争条件；不存在多进程或多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
4. 使用多路I/O复用模型，非阻塞IO
5. 底层模型不同，Redis构建了自己的VM机制，因为一般的系统调用系统函数，<font color=red>会有一定的时间和移动去请求</font>？

## 8. 过期策略

定期删除（随机抽取一些设置了过期时间的key）+惰性删除（使用到了再查看是否过期）



---

# 7. 操作系统

## 1. 进程间通信方式

管道，消息队列，共享内存，信号量，信号，Socket



进程的用户地址空间是独立的，但是内核空间是每个进程共享的，因此进程通信必须要通过内核

![进程通信](D:\Desktop\markdown\images\进程通信.png)

### 1.1 管道

#### 1. 匿名管道

linux命令中的竖线“|”就是一个管道，功能是将前一个命令(ps auxf)的输出，作为后一个命令(grep mysql)的输入；从功能描述可以看出**匿名管道数据传输是单项向**的

```sql
$ ps auxf | grep mysql
```

#### 2. 有名管道（FIFO），数据先进先出

使用管道前，用`mkfifo`创建，指定管道名字

```sql
$ mkfifo myPipe
```

linux一切皆文件，myPipe这个管道也是文件的方式存在

- 写入数据：只有管道的**数据被读完**后，命令才能正常退出

```sql
$ echo "hello" > myPipe  // 将数据写进管道
                         // 停住了 ...
```

- 读数据：

```sql
$ cat < myPipe  // 读取管道里的数据
hello
```

#### 3. 优缺点

1. **优点**：简单；

   	2. **缺点**：通信效率低，不适合进程间频繁交换数据。

#### 4. 管道的实质和背后原理

管道其实是**内核里面一段缓存**

### 1.2 消息队列

#### 1. 本质

消息队列是保存在**内核中的消息链表**，发送数据时，会分成一个个独立的数据单元，也就是消息体（数据块）

**消息体**是自定义的数据类型，通信双方要提前约定好，每个消息体都是固定大小的存储块，而不是管道中无格式的字节流数据

#### 2. 生命周期

1. 消息队列的生命周期取决于内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在

2. 匿名管道的生命周期，取决于进程的创建和销毁

#### 3. 优缺点

1. 优点：可以在进程间频繁交换数据
2. 缺点：
   - 通信不及时：**消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。
   - 附件有大小限制：**消息队列不适合比较大数据的传输**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 `MSGMAX` 和 `MSGMNB`，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。

### 1.3 共享内存

**内存管理：**采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。

**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**，大大提升了通信速度

![共享内存](D:\Desktop\markdown\images\共享内存.jpg)

### 1.4 信号量

```
共享内存的问题：多线程的并发问题，例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。

为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，**信号量**就实现了这一保护机制。

**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。

信号量表示自愿数量，两种原子操作控制信号量：
```

1. 一个是 **P 操作**，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。

2. 另一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

3. P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。

   

#### 1. 互斥信号量：初始化为1

```
**具体过程**举例：
```

![信号量](D:\Desktop\markdown\images\信号量.jpg)

- 进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。

- 若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。

- 直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。

  

  信号初始化为 `1`，就代表着是**互斥信号量**，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。



#### 2.同步信号量

```
**生产者，消费者举例**：**信号量来实现多进程同步**，多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、	不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的
```

![同步信号量](D:\Desktop\markdown\images\同步信号量.jpg)

具体过程：

- 如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；
- 接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；
- 最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。

信号初始化为 `0`，就代表着是**同步信号量**

### 1.5 信号

```
上面说的进程间通信，都是常规状态下的工作模式。**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**

与信号量完全不同，像java和javaScript

在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 `kill -l` 命令，查看所有的信号

运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如
```

- Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；
- Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束；

	信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式

**1. 执行默认操作**。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。

**2. 捕捉信号**。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。

**3. 忽略信号**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，它们用于在任何时候中断或结束某一进程。

### 1.6 Socket

前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。**同主机也可以













# 网易面试



## 1. AQS原理

[AQS](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)

![img](D:\Desktop\markdown\images\AQS)





## 2. limit的问题

```
order by的排序规律：
```

1. 有索引，按照索引排序
2. 无索引，使用排序算法
   1. 如果排序的内容全能放到内存，用快排
   2. 如果不能全放入内存，分批次排序并放入文件，然后对多个文件进行归并排序
3. 如果包含limit语句，使用堆排序优化



存在问题：limit 5和limit 5，10 会出现重复的数据

```sql
select * from user_info order by category limit ***;
```

因为堆排序不稳定

![堆排序不稳定.png)](D:\Desktop\markdown\images\堆排序不稳定.png)

解决：

1. 排序中加上唯一值，比如主键，由于主键唯一，会保证排序的key值不相同
2. 避免堆排序，让order by根据索引排序

## 3. innoDB聚集索引和普通索引

聚集索引叶子节点存储行记录

普通索引叶子节点存储主键值，注：不是存储头指针，MyISAM的索引叶子节点存储记录指针

![两种索引对比.png](D:\Desktop\markdown\images\两种索引对比.png)

## 4. 回表和如何避免

![回表.png](D:\Desktop\markdown\images\回表.png)

解决：**索引覆盖**

![覆盖举例.png](D:\Desktop\markdown\images\覆盖举例.png)

![覆盖举例2.png](D:\Desktop\markdown\images\覆盖举例2.png)













![排序底层.png](D:\Desktop\markdown\images\排序底层.png)



# 京东面试

AQS

缓存穿透

分布式的组件

泛型的类型擦除

ES的原理，如何实现文本匹配，调用的哪个接口

ThreadLocal

# 顺丰

内存泄漏和内存溢出

JVM频繁FULL GC怎么办









































![并行和并发](D:\Desktop\markdown\images\并行和并发.png)