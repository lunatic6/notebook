# 1. TCP/IP

## 1. 如何确保可靠传输

1. 确认和超时重传
2. 数据校验
3. 数据合理分片和排序
   1. 根据MTU（最大传输单元）分配，接收方缓存未按序到达的数据，重新排序后再交给应用层
4. 流量控制：提示发送方降低速率，防止丢包
5. 滑动窗口和快重传
6. 拥塞控制
7. 队头阻塞：在2.1.5中说明

## 2. 三次握手和四次挥手

序号：

- seq：sequence number 的缩写，直译的话，序号，对没错，它就是序号，你没有翻译错，相信自己，而这个seq表示的则是自己传递的序号，TCP在传输的时候，其中的每一个字节，都会有一个序号，发送数据的时候，会把第一个数据的第一个序号发送给对方，就是我们所看到的第一步，而接收的这一方面，会按照这个序号来检查是否是一个连接完整的数据，如果说你数据是完整的，那么好，我们可以继续下一步，如果你不是完整的，那就重新传送呗，而这样的话也能保证数据的完整性不被破坏。
- ack：注意，这是小写的ack，也就是acknoledgement number的缩写，而他表示的是确认号，这个要和ACK(确认位)进行区分，接收端这时候用它来给发送端返回成功接收消息的数据信息，而这时候，它的值就是表明，我现在想接收下一个数据包了，而这个值就是下一个数据包的开始的序号，而这个ack所代表的的值的序号前面的数据都已经接收成功了。
- ACK：确认位，确认位来了，只有当ACK=1的时候ack才会起到自己应该起的作用，而在我们第一次发起请求的时候，因为没有需要我们确认的接收的数据，所以这个时候的ACK就是0，而正常通信的情况下，ACK就1.
- SYN：同步位,而同步位的作用就是用于建立连接时同步序号，而刚连接的时候，说ACK是0，那么ack就不起作用，这时候SYN就来说，你看没我你们不行了把，要你们有何用，当接收端接收到SYN=1的报文的时候，就会将ack设置为接收到的seq+1的值，这也是大家在看百度上提供的内容的时候看到的，各种seq=k，ACK=k+1,这玩意就是这么来的，这时候ack的值就是根据SYN来直接设置的，这样你才能正常的进行传输，而SYN有时候会被面试官问到为什么在前两次握手的时候都是1呢？其实这是因为传输数据的双方的ack都是要一个初始值的，不然你还怎么传输，还怎么玩。

- FIN：终止位，这个在本图中，并没有完全的体现，在四次挥手的时候就能完全的体现出来了。而它则是用来在数据传输都完成之后来释放连接的。

### 1. 三次握手

![三次握手](D:\Desktop\markdown\计算机网\三次握手.png)

1.  第一次握手(SYN=1, seq=x):

   客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号(Sequence Number)字段里

   发送完毕后，客户端进入 SYN_SEND 状态。

2. 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

   服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。发送完毕后，服务器端进入 SYN_RCVD 状态。

3. 第三次握手(ACK=1，ACKnum=y+1);

   客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

   发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

### 2. 四次挥手

![四次挥手](D:\Desktop\markdown\计算机网\四次挥手.jpg)

1. 第一次挥手(FIN=1，seq=x)

   假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

   发送完毕后，客户端进入 FIN_WAIT_1 状态。

2. 第二次挥手(ACK=1，ACKnum=x+1)

   服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

   发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

3. 第三次挥手(FIN=1，seq=y)

   服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

   发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

4. 第四次挥手(ACK=1，ACKnum=y+1)

   客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。

   服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

   客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。两次后会重传直到超时。如果多了会有大量半链接阻塞队列。

### 3. 为什么不是三次挥手

​	这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。所以这时候挥手的时候就是四次，而不再是三次了。



# 2. HTTP/HTTPS

HTTP(hypertext transport protocol)翻译过来为"超文本传输协议"，文本可以理解为简单的字符文字组合，也可以理解为更为复杂的音频或者图像等。那么将这个词语拆分为三个部分。

1. "超文本"和"文本"相比多了一个字"超"，比文本丰富，因为它可以将多种文本/图像等进行混合，更重要的是可以从一个文本跳转到另一个文本(文本连接)。

2. "传输"，传输的过程中需要沟通，一对一沟通也可能一对多沟通(进行内容协商)，无论怎么样，参加沟通的人数>1，更快更好的完成相应的任务。

3. "协议"，让大家受一定的约束，违反了即有相应的惩罚。

![超文本传输协议](D:\Desktop\markdown\计算机网\超文本传输协议.png)





## 1. 发展过程（不同版本）

### 1.1 HTTP 0.9

​	当时网络资源匮乏，0.9版本相对简单，采用纯文本格式，且设置为只读，所以当时只能使用"Get"的方式从服务器获得HTML文档，响应以后则关闭

```http
GET /Mysite.html
```

​	响应中只包含了文档本身。响应内容无响应头，无错误码，无状态码，可以说是"裸奔"。

```http
<HTML>
Hello world
</HTML>
HTTP/1.0
```

**请求过程：**

- 应用层的HTTP建立在传输层的TCP之上并运用TCP可靠性等特性，先三次握手建立连接
- 客户端请求建立连接(此时只有GET)
- 服务端响应请求，数据以 **ASCII 字符流**返回给客戶端
- 传输完成，断开连接。

![http0.9](D:\Desktop\markdown\计算机网\http0.9.png)

### 1.2 HTTP 1.0

​	随着时代的进步，仅仅文本的传输无法满足需求，更多情况需要采用**图文**的方式才能生动的表达出自己的观点。

​	**增加了几个方面：**

- 之前只有Get方法，现在增加Post(加参数)，Head方法；
- 加入协议版本号，同时添加文件处理类型
- 加入HTTP Header，让HTTP处理请求更加灵活
- 增加响应状态码，标记出错的原因
- 提供国际化(不同语言)支持

```http
GET /image.html HTTP/1.0
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)

200 OK
Date: Tue, 17 Nov 2020 09:15:31 GMT
Content-Type: text/html
<HTML> 
一个包含图片的页面
  <IMG SRC="/image.gif">
</HTML>
```

**请求过程：**

![http1.0](D:\Desktop\markdown\计算机网\http1.0.png)



### 1.3 HTTP 1.1

​	随着文件越来越大，图片等信息越来越复杂，如果每一次上传下载文件都需要建立连接断开连接的过程将增加大量的开销。为此，提出了**持久连接**，也就是一次TCP连接可以具有多个HTTP请求。当然持久连接是可选择的，如果考虑关闭，只需要使用`Connecttion:close`关闭即可

​	**增加：**

- 继续增加了PUT等方法
- 允许持久连接



​	**请求过程：**

![http1.1](D:\Desktop\markdown\计算机网\http1.1.png)

​	**强制要求host头**：在电商系统中，经常会因为促销活动导致流量飙升，为了缓解流量，其中有种方法即加缓存或者加服务器。如果是单台服务器负载过大，数据库可能分库分表。数据结构算法中分而治之方法亦是如此。那么HTTP中，同样的道理，如果文件太大，就大文件切分为小文件块发送。？？？？？？？？？跟host头是什么关系



![http1.1管道技术和2.0数据分帧](D:\Desktop\markdown\计算机网\http1.1管道技术和2.0数据分帧.png)

​	HTTP/1.1通过pipelining管道技术实现一次性发送多个请求，以期提高吞吐和性能，如上图中的序列2（序列1是非管道化的请求）。然而，这种技术在接收响应时，要求必须按照发送请求的顺序返回。如果，第一个请求被堵塞了，则后面的请求即使处理完毕了，也需要等待，如上图中的序列3。

​	HTTP/2是怎么解决这个问题的呢？那就是数据分帧：多个请求复用一个TCP连接，然后每个request-response都被拆分为若干个frame发送，这样即使一个请求被阻塞了，也不会影响其他请求，如上图序列4所示。问题完美解决了？准确说，只解决了一部分。

### 1.4 HTTP 2.0

http 1.1中几点问题：

1. **TCP自带慢启动**

   ​	"慢启动"从0到1循循渐进。轿车启动不会按下按钮就直接起飞，而是缓慢调节到适合的速度。这不是挺好的？为什么会带来性能问题呢。

   ​	一个页面有静态数据，动态页面，很多小文件在加载的过程中就会直接发起请求，这样导致太多的请求都会经历慢启动过程，花费时间太多。

2. **多条TCP连接带宽竞争**

   ​	带宽固定，多条TCP连接同时发起竞争带宽资源，由于各个TCP连接之间没有通信机制，也无法得知哪些资源优先级更高，从而导致想快速下载的资源反而延迟下载

3. **头部阻塞**

   ​	网络编程中，我们采用异步，多路复用(epoll)方式尽量让cpu少等待多干事。在HTTP1.1中，虽然大家共用了一条TCP通道，但是第一个请求没有结束，第二请求就可能阻塞等待，也就是说不能同时发送接收数据。那么一个网页很多数据文件，如果能够同时发出请求，让部分数据文件能够得到响应并预处理，这样就大大的利用了带宽和cpu的资源。基于这些因素，在HTTP2中出现了新的方案



​	HTTP是一问一答的模式，大家都在这个队列排队导致堵塞，那就多个队列并发进行，也就是"对同一个域名发起多个长连接"。举个例子，在火车站排队买票的时候，如果只有一个窗口可用，大家只能苦等，多开几个窗口就可缓解这个问题。

​	这个时候用户数 * 并发数(上限6-8)已经不错得效果，但是互联网速度太快，火车站就这么大，窗口也就这么多，怎么办，建新的火车站进行分流(大部分城市都有什么东站 西站)。在这里叫做"域名分片"，使用多个域名，这些域名指向同一服务器。

​	HTTP/2主要做的事情：

1. 通过TCP多路复用降低延迟；

2. 单个TCP连接上允许乱序request-response，解决队头堵塞问题；

3. 实现层面上，大部分浏览器要求HTTP/2必须开启TLS，一定程度上解决数据安全问题。

   

   **头部阻塞的解决：**

   HTTP1.1中管道化导致的**请求/响应级别的队头阻塞**，在HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。

   

4. HTTP/2 over TCP(我们接触最多的HTTP/2)解决了http request级别的队头阻塞问题

2. HTTP/2 over QUIC解决了传输层的队头阻塞问题，是我们理解的真正解决了该问题。

### 1.5 头部阻塞的问题

#### 1. TCP队头阻塞（还有快重传机制）

​	队头阻塞（head-of-line blocking）发生在一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止。该后续分节的延迟递送确保接收应用进程能够按照发送端的发送顺序接收数据。这种为了达到完全有序而引入的延迟机制非常有用，但也有不利之处。

​	假设在单个TCP连接上发送语义独立的消息，比如说服务器可能发送3幅不同的图像供Web浏览器显示。为了营造这几幅图像在用户屏幕上并行显示的效果，服务器先发送第一幅图像的一个断片，再发送第二幅图像的一个断片，然后再发送第三幅图像的一个断片；服务器重复这个过程，直到这3幅图像全部成功地发送到浏览器为止。

​	要是第一幅图像的某个断片内容的TCP分节丢失了，客户端将保持已到达的不按序的所有数据，直到丢失的分节重传成功。这样不仅延缓了第一幅图像数据的递送，也延缓了第二幅和第三幅图像数据的递送。

​	**解决**：TCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。

#### 2. HTTP队头阻塞

##### 1. http管道化

HTTP1.1 允许在持久连接上可选的使用请求管道。这是相对于keep-alive连接的又一性能优化。在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。

因为HTTP管道化本身可能会导致队头阻塞的问题，以及一些其他的原因，现代浏览器默认都关闭了管道化。

![管道与非管道](D:\Desktop\markdown\计算机网\管道与非管道)

##### 2. HTTP管道化的限制

1. 管道化要求服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。
2. 客户端需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。
3. 只有幂等的请求才能进行管道化，也就是只有GET和HEAD请求才能管道化，否则可能会出现意料之外的结果

##### 3. HTTP管道化引起的请求队头阻塞

前面提到HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。


##### 4. 解决

对于HTTP1.1中管道化导致的**请求/响应级别的队头阻塞**，可以使用HTTP2解决。HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。



​	现代浏览器会针对单个域名开启6个连接，通过各个连接分别发送请求，一定程度上实现了并行，但是每个连接仍会搜到队头/头部阻塞的影响

### 1.6 HTTP 3.0   QUIC

[QUIC的中文详解](https://http3-explained.haxx.se/zh/zh)

​	基于UDP且能像TCP一样具有可靠性特点的协议。具备像HTTP/2一样的应用数据二进制分帧传输。其主要解决的问题有两个

1. 进一步解决线头阻塞问题。通过独立不同流，让各个流之间实现相互独立传输，互不干扰

 	2. 切换网络时的连接保持。wifi和3G/4G经常需要来回切换。基于TCP的协议，会因为网络的切换导致IP地址的改变。而基于UDP的QUIC协议，及时切换也可以恢复之前与服务器的连接。(这里推荐大家可以去看看MPTCP)

## 2. HTTP报文详解

![http报文示例.png](D:\Desktop\markdown\计算机网\http报文示例.png)

![请求报文1.png](D:\Desktop\markdown\计算机网\请求报文1.png)

### 1. 请求报文

![报文.png](D:\Desktop\markdown\计算机网\报文.png)

1. 请求方法

![请求方法.png](D:\Desktop\markdown\计算机网\请求方法.png)

2. URI

   ![1.png](D:\Desktop\markdown\计算机网\1.png)

![2.png](D:\Desktop\markdown\计算机网\2.png)

![3.png](D:\Desktop\markdown\计算机网\3.png)

### 2. 请求体

 ![请求体.png](D:\Desktop\markdown\计算机网\请求体.png)

![image-20200813153955804](D:\Desktop\markdown\计算机网\请求体1.png)

![请求体3.png](D:\Desktop\markdown\计算机网\请求体3.png)

![请体6.png](D:\Desktop\markdown\计算机网\请求体6.png)

![请求5.png](D:\Desktop\markdown\计算机网\请求5.png)

![请求7.png](D:\Desktop\markdown\计算机网\请求7.png)

![请求8.png](D:\Desktop\markdown\计算机网\请求8.png)

### 3. 响应报文

![响应.png](D:\Desktop\markdown\计算机网\响应.png)

![状态码.png](D:\Desktop\markdown\计算机网\状态码.png)









